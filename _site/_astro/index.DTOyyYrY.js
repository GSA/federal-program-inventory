import{r as s,R as v,g as M}from"./index.D_V1ncUJ.js";import{r as h}from"./index.BUVYuSZh.js";function k(e,n,{checkForDefaultPrevented:t=!0}={}){return function(o){if(e?.(o),t===!1||!o.defaultPrevented)return n?.(o)}}function g(e,n){if(typeof e=="function")return e(n);e!=null&&(e.current=n)}function S(...e){return n=>{let t=!1;const r=e.map(o=>{const i=g(o,n);return!t&&typeof i=="function"&&(t=!0),i});if(t)return()=>{for(let o=0;o<r.length;o++){const i=r[o];typeof i=="function"?i():g(e[o],null)}}}}function C(...e){return s.useCallback(S(...e),e)}var R=globalThis?.document?s.useLayoutEffect:()=>{},O=v[" useId ".trim().toString()]||(()=>{}),I=0;function x(e){const[n,t]=s.useState(O());return R(()=>{t(r=>r??String(I++))},[e]),n?`radix-${n}`:""}var P=h();const $=M(P);function j(e){const n=s.useRef(e);return s.useEffect(()=>{n.current=e}),s.useMemo(()=>(...t)=>n.current?.(...t),[])}var T=v[" useInsertionEffect ".trim().toString()]||R;function q({prop:e,defaultProp:n,onChange:t=()=>{},caller:r}){const[o,i,m]=w({defaultProp:n,onChange:t}),a=e!==void 0,f=a?e:o;{const c=s.useRef(e!==void 0);s.useEffect(()=>{const l=c.current;l!==a&&console.warn(`${r} is changing from ${l?"controlled":"uncontrolled"} to ${a?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),c.current=a},[a,r])}const u=s.useCallback(c=>{if(a){const l=U(c)?c(e):c;l!==e&&m.current?.(l)}else i(c)},[a,e,i,m]);return[f,u]}function w({defaultProp:e,onChange:n}){const[t,r]=s.useState(e),o=s.useRef(t),i=s.useRef(n);return T(()=>{i.current=n},[n]),s.useEffect(()=>{o.current!==t&&(i.current?.(t),o.current=t)},[t,o]),[t,r,i]}function U(e){return typeof e=="function"}function D(e,n){return s.useReducer((t,r)=>n[t][r]??t,e)}var b=e=>{const{present:n,children:t}=e,r=L(n),o=typeof t=="function"?t({present:r.isPresent}):s.Children.only(t),i=C(r.ref,F(o));return typeof t=="function"||r.isPresent?s.cloneElement(o,{ref:i}):null};b.displayName="Presence";function L(e){const[n,t]=s.useState(),r=s.useRef(null),o=s.useRef(e),i=s.useRef("none"),m=e?"mounted":"unmounted",[a,f]=D(m,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return s.useEffect(()=>{const u=N(r.current);i.current=a==="mounted"?u:"none"},[a]),R(()=>{const u=r.current,c=o.current;if(c!==e){const p=i.current,d=N(u);e?f("MOUNT"):d==="none"||u?.display==="none"?f("UNMOUNT"):f(c&&p!==d?"ANIMATION_OUT":"UNMOUNT"),o.current=e}},[e,f]),R(()=>{if(n){let u;const c=n.ownerDocument.defaultView??window,l=d=>{const A=N(r.current).includes(CSS.escape(d.animationName));if(d.target===n&&A&&(f("ANIMATION_END"),!o.current)){const y=n.style.animationFillMode;n.style.animationFillMode="forwards",u=c.setTimeout(()=>{n.style.animationFillMode==="forwards"&&(n.style.animationFillMode=y)})}},p=d=>{d.target===n&&(i.current=N(r.current))};return n.addEventListener("animationstart",p),n.addEventListener("animationcancel",l),n.addEventListener("animationend",l),()=>{c.clearTimeout(u),n.removeEventListener("animationstart",p),n.removeEventListener("animationcancel",l),n.removeEventListener("animationend",l)}}else f("ANIMATION_END")},[n,f]),{isPresent:["mounted","unmountSuspended"].includes(a),ref:s.useCallback(u=>{r.current=u?getComputedStyle(u):null,t(u)},[])}}function N(e){return e?.animationName||"none"}function F(e){let n=Object.getOwnPropertyDescriptor(e.props,"ref")?.get,t=n&&"isReactWarning"in n&&n.isReactWarning;return t?e.ref:(n=Object.getOwnPropertyDescriptor(e,"ref")?.get,t=n&&"isReactWarning"in n&&n.isReactWarning,t?e.props.ref:e.props.ref||e.ref)}export{b as P,$ as R,x as a,q as b,S as c,k as d,R as e,j as f,P as r,C as u};
